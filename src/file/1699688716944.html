<!DOCTYPE html>
<html>
<head>
<title>Document</title>
</head>
<body>
<ul>  首页    首页  沸点   课程   直播  活动  竞赛   商城    APP  插件            搜索历史  清空      创作者中心        写文章   发沸点   写笔记   写代码   草稿箱    创作灵感  查看更多                会员        登录  注册  </ul><li>首页    首页  沸点   课程   直播  活动  竞赛   商城    APP  插件  </li><ul>首页  沸点   课程   直播  活动  竞赛   商城    APP  插件  </ul><li>首页</li><li>沸点 </li><li>课程 </li><li>直播</li><li>活动</li><li>竞赛 </li><ul>        搜索历史  清空      创作者中心        写文章   发沸点   写笔记   写代码   草稿箱    创作灵感  查看更多                会员        登录  注册  </ul><li>        搜索历史  清空      创作者中心        写文章   发沸点   写笔记   写代码   草稿箱    创作灵感  查看更多          </li><ul>        搜索历史  清空      创作者中心        写文章   发沸点   写笔记   写代码   草稿箱    创作灵感  查看更多          </ul><li>        搜索历史  清空  </li><li>  创作者中心        写文章   发沸点   写笔记   写代码   草稿箱    创作灵感  查看更多          </li><ul>  写文章   发沸点   写笔记   写代码   草稿箱</ul><li>  写文章</li><li>  发沸点</li><li>  写笔记</li><li>  写代码</li><li>  草稿箱</li><li>    会员</li><li>登录  注册  </li><h1>【Node】之那些社区常用框架：express、koa、egg 该怎么上手？   </h1><p>写这篇文章是由于我之前有接触过一段时间的 Node ，之前做前端一直是在用别人的接口，当试着自己写接口，从另一个角度看待前端和后端后，感觉蛮有意思。最近离职了，时间比较充裕就把这三个框架都过一遍， 毕竟都说前端的尽头是全栈 ，哈哈哈，整个学习过程，让我对于服务器、浏览器的理解加深了，也便于自己对项目的全局理解。</p><h2>本篇文章不过多介绍关于这几个框架的理论知识，我一贯认为： 能上手写尽量不啰嗦 ，关于你想了解更多，这里奉献上几个框架的官网地址 express 、 koa 、 egg</h2><p>如果你想了解原生 node 的一些使用操作， 请点击这里</p><h1>一、 Node 框架之 express</h1><p>上手简单，自带路由，新手可以使用 express 找感觉</p><p>下载：</p><p>下载完成后，我们来看看具体的使用：</p><h2>1. 自带路由</h2><p>启动服务：</p><p>浏览器端：</p><p></p><h2>2. 同一个请求可以进行多次处理 next()</h2><p>需要手动调用 next</p><p>启动服务，控制台正常打印：</p><p></p><h2>3. 支持 get 、post 、 use 的请求</h2><p>支持 get  post 的请求，如果不确定什么请求，可以用 use</p><h2>4. 处理文件</h2><p>在处理数据时，大部分需要使用 中间件 ，这个就做个简述，中间件：顾名思义就是帮我们处理一些小的操作或者数据解析之类的小玩意，在后面我们用到时候会具体介绍。</p><p>1.html 文件</p><p></p><p>server.js</p><p>启动服务器，查看资源已经被拿到了：</p><p></p><h3>get 请求的数据处理</h3><p>启动服务器，打开浏览器端：</p><p></p><p>打开控制台，请求的数据已经被解析：</p><p></p><h3>post 请求处理数据</h3><p>下载中间件：</p><p>示例表单：</p><p>处理js:</p><p>启动服务，打开浏览器输入信息：</p><p></p><p>打开控制台，数据已经被解析：</p><p></p><h3>模拟实现 body-parser ：</h3><p>如果不考虑文件上传，我们来模拟一下这个 body-parser ，看一下它具体的实现原理是怎样的:</p><p>页面仍然使用这个提交页面：</p><p></p><p>查看控制台的解析，成功！！！：</p><p></p><p>再进一步封装：</p><p>body-parser.js</p><p>使用页面：</p><p>启动服务器测试，效果一样，封装成功！：</p><p></p><h3>处理文件上传 multer</h3><p>1.html 上传页面</p><p>处理数据：</p><p>启动服务，浏览器上传文件：</p><p></p><p>查看控制台输出：</p><p></p><p>浏览器处理完的成功提示：</p><p></p><p>查看上传完成的文件：</p><p></p><p>cookie 不跨域的</p><p>子域名可以访问主域名</p><p>只能向上，不能向下</p><p>domain:</p><h2>5. 处理 cookie</h2><p>先去下载一个中间件：</p><p>普通的存取 cookie :</p><p>重启服务，我们在浏览器看到已经存好了，且过期时间也设置上了：</p><p></p><p>控制台看一下获取cookie:</p><p></p><h3>带签名的 cookie ：</h3><p>我们知道cookie 是非常不安全的，在浏览器里是可以像这样手动随意修改的，那么有没有一个办法去限制修改呢，那就要说签名这个话题了。</p><p></p><p>如何来设置签名：</p><p>看一下浏览器端：</p><p></p><p>我们看到我们的值被存储为一堆我们不认识的编码，那么它到底是什么？</p><p>我们来解析一下：</p><p>s 代表我们的值是签名过的</p><p>通过 decodeURIComponent('%3A') , '%3A 解析出来是 : 冒号</p><p>Vbc4AX1PPW%2FeDBZexBICvp3lNB9Xx8qpE5Gm9UROIu0 这是使用我们之前给服务器的 welmxxfoiweorkpwk9834534nsd8j8u 这个编码又重新编译的值。</p><p>此时我们再看下控制台输出的结果，也是可以正常打印出来的：</p><p></p><p>我们再去浏览器修改一下，重新刷新浏览器看到值被还原了，也就是没有修改成功，且控制台提示我们这个值不被认可：</p><p></p><p>此时我们的目的已经达到了，签名也在一定程度上提高了cookie 的安全性。</p><h2>6.处理 session</h2><p>session 一般用来放用户登录信息，具体的信息存储在服务器，是不加密的:</p><p>启动服务器，看到浏览器已经把我的 session 存上了，且我们发现除了 session ，还多了一个 session.sig ，这个就是使用我们的循环密钥生成的签名。</p><p></p><p>我们尝试来存一些敏感数据：</p><p>我们看到前台并 不会新增字段 ，因为它只会存储一个 session 的 id ，用来识别身份，所以比较安全：</p><p></p><p>express 就介绍到这里，下面我们来看一下 express 的升级版 koa</p><h1>二、 Node 框架之 Koa</h1><p>koa 和 express 同一个团队开发的，本身区别不是很大，思想有些区别，然后就是写法上面的不同 koa@v1 / v2/ v3</p><p>express 基于回调的思想</p><p>koa: 利用 promise 的思想</p><p>下载(koa 不带路由，所以需要再下载一个路由)：</p><p>来个示例：</p><p>启动服务器，看一下浏览器是否已经有内容：</p><p></p><h3>嵌套路由</h3><p>我们在上面知道koa 的路由是需要单独下载的，那么把路由抽离出来的目的其实也是为了方便路由在项目中的使用，这一部分就来分析一下多层嵌套路由的使用：</p><p>下面就是我们示例中嵌套层级，如果是实际开放项目中，路由可以单独抽离一个文件来管理，看起来就不会这么凌乱：</p><h3>路由带参</h3><p>启动服务，查看浏览器如何传参：</p><p>当有一个参数时：</p><p></p><p>当有三个参数时：</p><p></p><p>当传参方式用 ？ 的形式，用 query 来取参：</p><p></p><h3>server.context</h3><p>相当于ctx 的proptype，在server.context 挂的参数是可以在ctx 上取的，适用于挂一些全局使用的内容</p><p></p><h3>ctx.throw</h3><p>用于抛错</p><p></p><h3>ctx.assert</h3><h3>ctx.state 状态码</h3><p></p><h3>ctx.redirect 重定向</h3><p></p><h3>koa-static</h3><p>访问静态资源</p><p>基本使用：</p><p>创建一个static 文件，存放静态资源;</p><p></p><p>当前有一个1.html:</p><p>server.js</p><p>启动服务去请求静态资源，资源被成功拿到：</p><p></p><p>当然我们koa 的static 是可以设置缓存时间的，在一定程度上减轻服务器的压力，下面我们一起来试试吧：</p><p>maxage 设置缓存时间</p><p></p><p>index 设置默认文件</p><p></p><p>可根据文件类型设置不同缓存时间：</p><p></p><p></p><h3>cookie</h3><p>koa 是自带cookie的，所以我们就可以直接用</p><p>设置cookie:</p><p></p><p>获取cookie:</p><p></p><h4>koa-session</h4><p></p><h1>三、 Node 框架之 Egg</h1><p>Egg.js 是阿里旗下的一个基于 nodejs 和 koa2 的企业级应用框架，基于 es6 ， es7 和 nodejs 。之前项目有用到egg 来搭建一个简单的服务，下面就来分享一下我的使用感受。</p><h2>特性</h2><ul> 提供基于 Egg 定制上层框架 的能力  高度可扩展的 插件机制  内置 多进程管理  基于 Koa 开发，性能优异  框架稳定，测试覆盖率高  渐进式开发 </ul><li>提供基于 Egg 定制上层框架 的能力</li><li>高度可扩展的 插件机制</li><li>内置 多进程管理</li><li>基于 Koa 开发，性能优异</li><li>框架稳定，测试覆盖率高</li><li>渐进式开发</li><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。而 Egg 选择了 Koa 作为其基础框架，在它的模型基础上，进一步对它进行了一些增强。</p><p>所以吧，大概就是这么个关系：</p><p></p><p>----施主别走，加个关注，我还在持续补充中</p><p>Egg.js官网</p><p>Egg.js文档</p><h2>可能会有人问了：现在 egg 都已经可以替代 koa 和 express 了，那为啥还要学旧的呢？</h2><p>我其实是想说，框架出现的目的，是使我们可以更便捷的写代码，去实现业务的需求，所以学习哪个框架他们是不关心的，对我们个人来说，当你知道一个框架的演变过程后，你会对它有更深的理解，不同框架对于同一问题处理方式不同，不同的处理方式之间又有哪些差别，是思维的扩展，是解决问题的方式的延伸。</p><ul>本篇文章不过多介绍关于这几个框架的理论知识，我一贯认为：能上手写尽量不啰嗦，关于你想了解更多，这里奉献上几个框架的官网地址express、 koa、 egg   一、Node 框架之 express  1. 自带路由   2. 同一个请求可以进行多次处理 next()   3. 支持 get 、post 、 use的请求   4. 处理文件  get 请求的数据处理   post 请求处理数据   模拟实现body-parser：   处理文件上传 multer   5. 处理cookie  带签名的cookie：   6.处理session   二、 Node框架之Koa  嵌套路由   路由带参   server.context   ctx.throw   ctx.assert   ctx.state 状态码   ctx.redirect 重定向   koa-static   cookie  koa-session   三、Node框架之Egg  特性   可能会有人问了：现在egg 都已经可以替代 koa 和 express了，那为啥还要学旧的呢？  </ul><li>本篇文章不过多介绍关于这几个框架的理论知识，我一贯认为：能上手写尽量不啰嗦，关于你想了解更多，这里奉献上几个框架的官网地址express、 koa、 egg  </li><li>一、Node 框架之 express  1. 自带路由   2. 同一个请求可以进行多次处理 next()   3. 支持 get 、post 、 use的请求   4. 处理文件  get 请求的数据处理   post 请求处理数据   模拟实现body-parser：   处理文件上传 multer   5. 处理cookie  带签名的cookie：   6.处理session  </li><ul>1. 自带路由   2. 同一个请求可以进行多次处理 next()   3. 支持 get 、post 、 use的请求   4. 处理文件  get 请求的数据处理   post 请求处理数据   模拟实现body-parser：   处理文件上传 multer   5. 处理cookie  带签名的cookie：   6.处理session  </ul><li>1. 自带路由  </li><li>2. 同一个请求可以进行多次处理 next()  </li><li>3. 支持 get 、post 、 use的请求  </li><li>4. 处理文件  get 请求的数据处理   post 请求处理数据   模拟实现body-parser：   处理文件上传 multer  </li><ul>get 请求的数据处理   post 请求处理数据   模拟实现body-parser：   处理文件上传 multer  </ul><li>get 请求的数据处理  </li><li>post 请求处理数据  </li><li>模拟实现body-parser：  </li><li>处理文件上传 multer  </li><li>5. 处理cookie  带签名的cookie：  </li><ul>带签名的cookie：  </ul><li>带签名的cookie：  </li><li>6.处理session  </li><li>二、 Node框架之Koa  嵌套路由   路由带参   server.context   ctx.throw   ctx.assert   ctx.state 状态码   ctx.redirect 重定向   koa-static   cookie  koa-session  </li><ul>嵌套路由   路由带参   server.context   ctx.throw   ctx.assert   ctx.state 状态码   ctx.redirect 重定向   koa-static   cookie  koa-session  </ul><li>嵌套路由  </li><li>路由带参  </li><li>server.context  </li><li>ctx.throw  </li><li>ctx.assert  </li><li>ctx.state 状态码  </li><li>ctx.redirect 重定向  </li><li>koa-static  </li><li>cookie  koa-session  </li><ul>koa-session  </ul><li>koa-session  </li><li>三、Node框架之Egg  特性   可能会有人问了：现在egg 都已经可以替代 koa 和 express了，那为啥还要学旧的呢？  </li><ul>特性   可能会有人问了：现在egg 都已经可以替代 koa 和 express了，那为啥还要学旧的呢？  </ul><li>特性  </li><li>可能会有人问了：现在egg 都已经可以替代 koa 和 express了，那为啥还要学旧的呢？  </li><p>友情链接：</p><ul>抖音聊天 抖音聊天</ul><li>抖音聊天</li><li>抖音聊天</li>
</body>
</html>